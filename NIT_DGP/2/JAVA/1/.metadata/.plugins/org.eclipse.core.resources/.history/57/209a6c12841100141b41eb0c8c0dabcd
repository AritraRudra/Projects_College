import java.util.ArrayList;
import java.util.Random;

public class Individual {
	private int  index, chromosomeLength; //maxLength = 5*32;//No of nodes = 32 hence 0-31 -> binary 00000 - 11111, 5 bits, mind that length will always be a multiple of 5
	private double delay = 0.0, energy = 0.0;
	//private byte[] genes = new byte[defaultGeneLength];	//Chromosome
	private int[] genes;// = new int[defaultGeneLength];
	public int[][] adjMat;
	public double[][] actMatDelay, actMatEnrg, S;
	private int fitnessLevel, dominatesMe = 0;	// 0 is the best level,  np, the number of solutions which dominate this solution
	private int[] iDominate;	//Sp, a set of solutions which this solution dominates, contains their index nos.
	private double crowdingDist = 0;
	//private ArrayList<Integer> myDominanceList = new ArrayList<Integer>();	//Sp, a set of solutions which this solution dominates
	private ArrayList<Individual> myDominanceList = new ArrayList<Individual>();	//Sp, a set of solutions which this solution dominates


	public Individual(){
		//this.genes = new int[chromosomeLength];
		this.delay = 0.0;
		this.energy = 0.0;
	}

	// Create a random individual
	public void generateChromosome(String keyword, int noOfNodes, int goalNode) {
		int i, j, k, pos, noOfNbrs = 0;
		int currNode, nextNodePos, nextNode;
		int[] tempArr1 = new int[noOfNodes];
		int[] tempPath = new int[noOfNodes];
		//Graph graph = new Graph(adjMat, defaultGeneLength, 0);
		//For random generation
		if(keyword.equals("RANDOM")){
			boolean assigned;
			Random rand = new Random();
			this.chromosomeLength = rand.nextInt((noOfNbrs-2)) + 2;	//min length = 2, max length = 32	//TODO
			this.genes = new int[this.chromosomeLength];
			this.genes[0] = 0;
			this.genes[(this.chromosomeLength - 1)] = goalNode;
			for (i = 1; i < (this.chromosomeLength - 1) ; i++) {
				assigned  = false;
				while(!assigned){
					k = i;	//position
					nextNode = rand.nextInt(noOfNodes - 2) + 1;		//possible node nos. : 1 to 30
					for (j = 1; j < k ; j++) {
						if(this.genes[j] == nextNode){
							//assigned = false;
							break;
						}
					}
					if( j == k ){
						this.genes[k] = nextNode;
						assigned = true;
					}
				}
			}
			//this.printChromosome();
		}
		else if(keyword.equals("HEURISTIC")){
			int delThisNode;
			boolean reachedLastNode = false;
			Random rand = new Random();
			//Finds the nbrs of the starting node , i.e., first node
			currNode = 0;
			tempPath[0] = 0;
			for (i = 0; i < noOfNodes ; i++) {
				if(adjMat[currNode][i] == 1){
					tempArr1[noOfNbrs] = i;
					noOfNbrs++;
				}
			}

			nextNodePos = rand.nextInt(noOfNbrs);		// returns a random number between 0 and indiv.length() (31)
			nextNode = tempArr1[nextNodePos];
			tempPath[1] = nextNode;
			pos = 2;
			while(!reachedLastNode){
				//check if target node is reached
				if(nextNode == goalNode){
					reachedLastNode = true;
					//TODO check it but seems OK
					break;
				}
				/*
				//avoid selecting the starting node
				else if(nextNode == 0){
					nextNodePos = rand.nextInt(noOfNbrs -1) + 1;
					nextNode = tempArr1[nextNodePos];
				}
				 */
				currNode = nextNode;
				noOfNbrs = 0;
				for (i = 0; i < noOfNodes ; i++) {
					if(adjMat[currNode][i] == 1){
						tempArr1[noOfNbrs] = i;
						noOfNbrs++;
					}
				}
				nextNodePos = rand.nextInt(noOfNbrs);
				nextNode = tempArr1[nextNodePos];

				//loop identification and removal i.e., if nextNode was encountered and added previously
				for (i = 0; i < pos ; i++) {
					if(tempPath[i] == nextNode){
						//remove all after this point
						delThisNode = tempPath[i+1];	//don't consider this node during random choosing as it may lead to the formation of loop(s) 
						for ( j = i+1; j < pos; j++) {
							tempPath[j] = -1;
						}
						noOfNbrs = 0;
						for (k = 0; k < noOfNodes ; k++) {
							if((adjMat[nextNode][k] == 1) && (k != delThisNode)){
								tempArr1[noOfNbrs] = k;
								noOfNbrs++;
							}
						}
						nextNodePos = rand.nextInt(noOfNbrs);
						nextNode = tempArr1[nextNodePos];
						pos = i+1;
						break;	//??!
					}
				}
				tempPath[pos] = nextNode;				
				pos++;				
			}
			//assign path as chromosome
			this.genes = new int[pos];
			this.chromosomeLength = pos;
			for (i = 0; i < pos ; i++){
				this.genes[i] = tempPath[i];
				//System.out.println(this.genes[i]);
				//System.out.println(tempPath[i]);
			}
			//reAdjustRoute(this.genes);
			//if(this.genes[2] == 0)	//avoid selecting the starting node, i.e., node 0
			removeLoops();
			//printChromosome();
		}
		//For BFS generation
		else if(keyword.equals("BFS")){
			Path path = new Path(adjMat, noOfNodes);
			genes = path.initilize_Get("BFS", goalNode);
			this.chromosomeLength = genes.length;
			//printChromosome();
		}
		//For DFS generation
		else {
			Path path = new Path(adjMat, noOfNodes);
			genes = path.initilize_Get("DFS", goalNode);
			this.chromosomeLength = genes.length;
			//printChromosome();
		}

		/*
			for (i = 0; i < size(); i++) {
				byte gene = (byte) Math.round(Math.random());
				genes[i] = gene;
			}
		 */	
	}


	//Only setters

	public void setAdjMat(int[][] adjMat) {
		this.adjMat = adjMat;
	}

	public void setActMatDelay(double[][] actMatDelay) {
		this.actMatDelay = actMatDelay;
	}

	public void setActMatEnrg(double[][] actMatEnrg) {
		this.actMatEnrg = actMatEnrg;
	}

	public void setS(double[][] S) {
		this.S = S;
	}

	public void setNetworkProp(int[][] adjMat, double[][] actMatDelay, double[][] actMatEnrg, double[][] S) {
		this.adjMat = adjMat;
		this.actMatDelay = actMatDelay;
		this.actMatEnrg = actMatEnrg;
		this.S = S;
	}

	//Both Getters and Setters
	public int getIndex() {
		return (this.index);
	}

	public void setIndex(int index) {
		this.index = index;
	}

	public int getGene(int index) {
		return (this.genes[index]);
	}

	public void setGene(int index, int value) {
		this.genes[index] = value;
		this.delay = 0.0;
		this.energy = 0.0;
	}

	public int[] getChromosome() {
		return (this.genes);
	}

	public void setChromosome(int[] chr) {
		this.genes = new int [chr.length];
		this.genes = chr;
		this.chromosomeLength = chr.length;
		this.delay = 0.0;
		this.energy = 0.0;
	}

	public int getChromosomeLength(){
		return (this.chromosomeLength);
	}

	// Use this if you want to create individuals with different gene lengths
	/*public void setChromosomeLength(int length) {
		this.chromosomeLength = length;
	}*/
	
	public int getDominatesMe() {
		return dominatesMe;
	}

	public void setDominatesMe(int dominatesMe) {
		this.dominatesMe = dominatesMe;
	}
	
	public void increaseDominatedCount() {
		this.dominatesMe++;
	}
	
	public void decreaseDominatedCount() {
		this.dominatesMe--;
	}

	public int[] getIDominate() {
		return iDominate;
	}

	public void setIDominate(int[] iDominate) {
		this.iDominate = iDominate;
	}
	
	public int getIDominateByIndex(int index) {
		return (this.iDominate[index]);
	}

	public void setIDominateByIndex(int index, int dominatedSolIndex) {
		this.genes[index] = dominatedSolIndex;
	}

	public int getFitnessLevel() {
		return this.fitnessLevel;
	}

	public void setFitnessLevel(int fitnessLevel) {
		this.fitnessLevel = fitnessLevel;
	}

	/*
	public ArrayList<Integer> getMyDominanceList() {
		return myDominanceList;
	}
	*/
	/*
	public void setMyDominanceList(ArrayList<Integer> myDominanceList) {
		this.myDominanceList = myDominanceList;
	}
	*/
	/*
	public void addToMyDominanceList(int dominatedSol) {
		this.myDominanceList.add(dominatedSol);
	}
	*/
	
	public ArrayList<Individual> getMyDominanceList() {
		return myDominanceList;
	}
	
	public void addToMyDominanceList(Individual dominatedIndiv) {
		this.myDominanceList.add(dominatedIndiv);
	}

	public double getCrowdingDist() {
		return crowdingDist;
	}

	public void setCrowdingDist(double crowdingDist) {
		this.crowdingDist = crowdingDist;
	}
	
	//End of Getters and Setters

	public double getDelay() {
		if (this.delay == 0.0) {
			this.delay = this.calculateDelay();
			return (this.delay);
		}else 
			return (this.delay);
	}

	public double getEnergy() {
		if (this.energy == 0.0) {
			this.energy = this.calculateEnergy();
			return (this.energy);
		}else 
			return (this.energy);
	}
	
	public void setDelay(double delay) {
		this.delay = delay;
	}
	
	public void setEnergy(double energy) {
		this.energy = energy;
	}
	
	public double getDelay(int[][] adjMat, double[][] actMatDelay, double[][] actMatEnrg, double[][] S) {
		this.setNetworkProp(adjMat, actMatDelay, actMatEnrg, S);
		if (this.delay == 0.0) {
			this.delay = this.calculateDelay();
			return (this.delay);
		}else 
			return (this.delay);
	}

	public double getEnergy(int[][] adjMat, double[][] actMatDelay, double[][] actMatEnrg, double[][] S) {
		this.setNetworkProp(adjMat, actMatDelay, actMatEnrg, S);
		if (this.energy == 0.0) {
			this.energy = this.calculateEnergy();
			return (this.energy);
		}else 
			return (this.energy);
	}

	//Route Delay calculation
	private double calculateDelay() {
		int a, b, i, len = this.chromosomeLength -1;
		double pathDelay = 0.0;
		for( i = 0; i < len ; i++){
			a = this.genes[i];
			b = this.genes[i+1];
			pathDelay += this.actMatDelay[a][b];
		}
		//System.out.println("Delay " + pathDelay);
		return pathDelay;
	}

	//Route Energy calculation	
	private double calculateEnergy() {
		int a, b, i, len = this.chromosomeLength -1;
		double pathEnergy = 0.0;
		for( i = 0; i < len ; i++){
			a = this.genes[i];
			b = this.genes[i+1];
			pathEnergy += this.actMatEnrg[a][b];
		}
		//System.out.println("Energy " + pathEnergy);
		return pathEnergy;
	}

	/*
	public double getFitness() {
		if (this.fitness == 0.0) {
			this.fitness = this.calculateFitness();
			return (this.fitness);
		}else 
			return (this.fitness);
	}

	public double getFitness(int[][] adjMat, double[][] costMatDelay, double[][] costMatEnrg, double[][] S) {
		this.setNetworkProp(adjMat, costMatDelay, costMatEnrg, S);
		if (this.fitness == 0.0) {
			this.fitness = this.calculateFitness();
			return (this.fitness);
		}else 
			return (this.fitness);
	}
	 */

	// returns route from the specified node including the supplied node		apply during mutation (4.pdf)
	public int[] getRouteFromNode(int nodeNo, int noOfNodes, int goalNode) {
		int i, j, k, pos, noOfNbrs = 0;
		int nextNodePos, nextNode, route[], looplessRoute[];
		int[] tempArr1 = new int[noOfNodes];
		int[] tempPath = new int[noOfNodes];
		int delThisNode;
		boolean reachedLastNode = false;
		Random rand = new Random();

		tempPath[0] = nodeNo;
		for (i = 0; i < noOfNodes ; i++) {
			if(this.adjMat[nodeNo][i] == 1){
				tempArr1[noOfNbrs] = i;
				noOfNbrs++;
			}
		}		
		nextNodePos = rand.nextInt(noOfNbrs);
		nextNode = tempArr1[nextNodePos];
		tempPath[1] = nextNode;
		pos = 2;

		while(!reachedLastNode){
			if(nextNode == goalNode){
				reachedLastNode = true;
				//TODO check it but seems OK
				break;
			}
			//else{
			nodeNo = nextNode;
			noOfNbrs = 0;
			for (i = 0; i < noOfNodes ; i++) {
				if(this.adjMat[nodeNo][i] == 1){
					tempArr1[noOfNbrs] = i;
					noOfNbrs++;
				}
			}
			nextNodePos = rand.nextInt(noOfNbrs);
			nextNode = tempArr1[nextNodePos];

			//loop identification and removal i.e., if nextNode was encountered and added previously
			for (i = 0; i < pos ; i++) {
				if(tempPath[i] == nextNode){
					//remove all after this point
					delThisNode = tempPath[i+1];	//don't consider this node during random choosing as it may lead to the formation of loop(s) 
					for ( j = i+1; j < pos; j++) {
						tempPath[j] = -1;
					}
					noOfNbrs = 0;
					for (k = 0; k < noOfNodes ; k++) {
						if((this.adjMat[nextNode][k] == 1) && (k != delThisNode)){
							tempArr1[noOfNbrs] = k;
							noOfNbrs++;
						}
					}
					nextNodePos = rand.nextInt(noOfNbrs);
					nextNode = tempArr1[nextNodePos];
					pos = i+1;
					break;	//??!
				}
			}
			tempPath[pos] = nextNode;				
			pos++;
		}

		route = new int[pos];
		for (i = 0; i < pos ; i++) 
			route[i] = tempPath[i];
		//return (route);

		looplessRoute = removeLoops(route);
		return (looplessRoute);
	}

	//removes single point loop, simpler approach
	/*
		public int[] reAdjustRoute(int[] oldRoute) {
			int i, j, k, lenOld = (oldRoute.length ), lenNew, index;
			//boolean loopMightExist = true;
			int[] tempRoute = new int[lenOld];
			int[] adjustedRoute;

			for (k = 0; k < lenOld ; k++)
				tempRoute[k] = -1;

			for (i = 0, j=0; i < ( lenOld - j) ; i++, j++) {
				//Find a loop
				if(oldRoute[i] == oldRoute[lenOld-1 - j]){
					//Eliminate the loop
					for (k = 0; k < (i - 1) ; k++) {
						tempRoute[k] = oldRoute[k];
					}
					for (k = (lenOld - j+1); k < lenOld ; k++) {
						tempRoute[k] = oldRoute[k];
					}

				}
			}

			lenNew = 0;
			for (k = 0; k < lenOld ; k++){
				if(tempRoute[k] != -1)
					lenNew++;
			}
			adjustedRoute = new int [lenNew];
			index = 0;
			for (k = 0; k < lenOld ; k++){
				if(tempRoute[k] != -1){
					adjustedRoute[index] = tempRoute[k];
					index++;
				}
			}
			return adjustedRoute;
		}
	 */

	//removes all loops, complex approach can not be used before genes are set
	//public int[] removeLoops() {
	public void removeLoops() {
		int i, j, k, lenOld = (this.genes.length ), index;
		int[] tempRoute = new int[lenOld];
		//int[] adjustedRoute;
		int[] oldRoute = this.genes;
		boolean loopMightExist = true;

		/*
			for (k = 0; k < lenOld ; k++)
				tempRoute[k] = -1;
		 */

		index = tempRoute.length;
		tempRoute = oldRoute;

		while(loopMightExist){
			//loop identification and removal from 4.pdf by searching in forward direction
			lenOld = index;
			oldRoute = tempRoute;
			for ( i = 0; i < lenOld; i++) {
				for ( j = i+1; j < lenOld; j++) {
					//Finds a loop
					if(oldRoute[j] == oldRoute[i]){
						//Eliminate the loop
						//removeLoop(oldRoute, i, j);
						//remove every node between i and j
						index = i+1;
						for (k = j+1; k <lenOld ; k++) {
							oldRoute[index]  = oldRoute[k];
							index++;
						}
						for (k = 0; k <index ; k++) {
							tempRoute[k] = oldRoute[k];
						}
						//System.out.println(index);
					}
				}
			}
			if(i == index)
				loopMightExist= false;
		}

		/*
			adjustedRoute = new int[index];
			for ( i = 0; i < index; i++)
				adjustedRoute[i] = tempRoute[i];
			//return adjustedRoute;	//tempRoute;
		 */

		this.genes = new int[index];
		this.chromosomeLength = index;
		for ( i = 0; i < index; i++)
			this.genes[i] = tempRoute[i];

	}

	private int[] removeLoops(int[] loopyRoute) {
		int i, j, k, lenOld = (loopyRoute.length ), index;
		int[] tempRoute = new int[lenOld];
		int[] adjustedRoute;
		int[] oldRoute = loopyRoute;
		boolean loopMightExist = true;

		/*
			for (k = 0; k < lenOld ; k++)
				tempRoute[k] = -1;
		 */

		index = tempRoute.length;
		tempRoute = oldRoute;

		while(loopMightExist){
			//loop identification and removal from 4.pdf by searching in forward direction
			lenOld = index;
			oldRoute = tempRoute;
			for ( i = 0; i < lenOld; i++) {
				for ( j = i+1; j < lenOld; j++) {
					//Finds a loop
					if(oldRoute[j] == oldRoute[i]){
						//Eliminate the loop
						//removeLoop(oldRoute, i, j);
						//remove every node between i and j
						index = i+1;
						for (k = j+1; k <lenOld ; k++) {
							oldRoute[index]  = oldRoute[k];
							index++;
						}
						for (k = 0; k <index ; k++) {
							tempRoute[k] = oldRoute[k];
						}
						//System.out.println(index);
					}
				}
			}
			if(i == index)
				loopMightExist= false;
		}

		adjustedRoute = new int[index];
		for ( i = 0; i < index; i++)
			adjustedRoute[i] = tempRoute[i];
		return adjustedRoute;	//tempRoute;

	}

	public void printChromosome() {
		int i;
		for (i = 0; i < this.chromosomeLength ; i++) {
			System.out.print((this.genes[i] + 1) + " ");
		}
		System.out.println();
	}

	/*				
		@Override
		public String toString() {
			int i;
			String geneString = "";
			for (i = 0; i < this.chromosomeLength ; i++) {
				geneString += getGene(i);
			}
			return geneString;
		}
	 */

}